# mini_shell

使用linux系统编程知识实现的mini_shell，支持输入/输出重定向，支持管道操作，支持基本的后台作业（暂不支持作业管理），支持内建命令。

## 实现思路

main函数中运行一个无限循环，不断地接收用户输入的命令、解析命令、执行用户命令。

在执行用户命令时，如果在主进程中调用exec函数执行用户命令，主进程的进程映像会完全被执行用户命令的进程替换，用户命令执行完毕后，整个程序就会退出。因此，我们fork出一个子进程，让子进程调用exec函数执行用户命令。

## 信号处理

用户在终端输入`ctrl+d`或`ctrl+\`后，终端向前台进程组发送SIGINT或SIGQUIT信号，默认使进程组中的进程退出。在main函数中将这两个信号的处理函数设置为刷新输出缓冲区。

子进程执行用户命令前，调用`setpgid()`和`tcsetpgrp()`使子进程成为前台进程组，从而可以收到用户输入终端的SIGINT或SIGQUIT信号，由于子进程的进程映像被完全替换，因此其信号处理函数恢复为默认动作，使子进程退出前台作业。同时，父进程不会收到这两个信号，不会刷新输出缓冲区。

子进程结束后，执行用户命令前，调用`tcsetpgrp()`令父进程成为前台进程组，由于设置了信号处理函数，用户输入`ctrl+d`或`ctrl+\`只会刷新输出缓冲区，不会使程序退出。

## IO重定向

假设用户输入以下命令：

```bash
cat < test.txt | grep -n extern | wc -l > test2.txt
```

该命令由管道操作符连接的三个基本命令构成，需要创建两个管道。

执行cat命令时，主进程创建第一个pipe（称为pipe_1），调用fork()，子进程将0（标准输入）重定向到test.txt，将1（标准输出）重定向到pipe_1[1]。执行完毕后，父进程关闭test.txt和pipe_1[1]。

执行grep命令时，主进程创建第二个pipe（称为pipe_2），调用fork()，子进程将0重定向到pipe_1[0]，将1重定向到pipe_2[1]。执行完毕后，父进程关闭pipe_1[0]和pipe_2[1]，从而第一个pipe关闭。

执行wc命令时，主进程调用fork()，子进程将0重定向到pipe_2[0]，将1重定向到test2.txt。执行完毕后，父进程关闭和pipe_2[0]和test2.txt，从而第二个pipe关闭。